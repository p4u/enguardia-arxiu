package generator

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/p4u/enguardia-arxiu/internal/collector"
)

// Generator handles the generation of webapp data files
type Generator struct {
	dataDir string
	tags    *TagDatabase
}

// TagDatabase represents the loaded tags data
type TagDatabase struct {
	Version     string                    `json:"version"`
	LastUpdated string                    `json:"last_updated"`
	Episodes    map[string]EpisodeTagData `json:"episodes"`
}

// EpisodeTagData represents tag data for a single episode
type EpisodeTagData struct {
	Title         string            `json:"title"`
	Tags          EpisodeTagsStruct `json:"tags"`
	Confidence    float64           `json:"confidence"`
	AutoGenerated bool              `json:"auto_generated"`
}

// EpisodeTagsStruct represents the categorized tags for an episode
type EpisodeTagsStruct struct {
	Topics        []string `json:"topics,omitempty"`
	Locations     []string `json:"locations,omitempty"`
	Civilizations []string `json:"civilizations,omitempty"`
	Events        []string `json:"events,omitempty"`
	Periods       []string `json:"periods,omitempty"`
}

// NewGenerator creates a new data generator
func NewGenerator(dataDir string) *Generator {
	return &Generator{
		dataDir: dataDir,
	}
}

// GenerateWebappData creates consolidated data for the webapp
func (g *Generator) GenerateWebappData(outputDir string, lazy bool) error {
	log.Println("Generating webapp data files...")

	// Load tags database
	if err := g.loadTagsDatabase(); err != nil {
		log.Printf("Warning: failed to load tags database: %v", err)
		// Continue without tags
	}

	// Load episodes from JSON files
	episodes, err := g.loadEpisodesFromJSON()
	if err != nil {
		return fmt.Errorf("failed to load episodes: %w", err)
	}

	// Convert to webapp episodes
	webappEpisodes := g.convertToWebappEpisodes(episodes, lazy)

	// Generate statistics
	stats := g.generateStats(webappEpisodes)

	// Create configuration
	config := g.createConfig(lazy)

	// Create webapp data structure
	webappData := WebappData{
		Episodes: webappEpisodes,
		Stats:    stats,
		Config:   config,
	}

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write main data file
	if err := g.writeJSONFile(filepath.Join(outputDir, "episodes.json"), webappData); err != nil {
		return fmt.Errorf("failed to write episodes.json: %w", err)
	}

	// Write separate files for different purposes
	if err := g.writeJSONFile(filepath.Join(outputDir, "episodes-list.json"), webappEpisodes); err != nil {
		return fmt.Errorf("failed to write episodes-list.json: %w", err)
	}

	if err := g.writeJSONFile(filepath.Join(outputDir, "stats.json"), stats); err != nil {
		return fmt.Errorf("failed to write stats.json: %w", err)
	}

	if err := g.writeJSONFile(filepath.Join(outputDir, "config.json"), config); err != nil {
		return fmt.Errorf("failed to write config.json: %w", err)
	}

	log.Printf("Successfully generated webapp data files in %s", outputDir)
	log.Printf("Total episodes: %d, Available: %d", stats.TotalEpisodes, stats.AvailableCount)

	return nil
}

// loadEpisodesFromJSON loads episodes from individual JSON files
func (g *Generator) loadEpisodesFromJSON() ([]collector.Episode, error) {
	var episodes []collector.Episode

	// Read all JSON files in the data directory
	files, err := filepath.Glob(filepath.Join(g.dataDir, "*.json"))
	if err != nil {
		return nil, fmt.Errorf("failed to glob JSON files: %w", err)
	}

	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			log.Printf("Warning: failed to read file %s: %v", file, err)
			continue
		}

		var episode collector.Episode
		if err := json.Unmarshal(data, &episode); err != nil {
			log.Printf("Warning: failed to parse JSON file %s: %v", file, err)
			continue
		}

		// Set JSONFile field based on filename
		episode.JSONFile = filepath.Base(file)
		episodes = append(episodes, episode)
	}

	// Sort episodes by title (which often contains episode numbers)
	sort.Slice(episodes, func(i, j int) bool {
		return g.extractEpisodeNumber(episodes[i].Title) < g.extractEpisodeNumber(episodes[j].Title)
	})

	return episodes, nil
}

// loadTagsDatabase loads the tags database from tags.json
func (g *Generator) loadTagsDatabase() error {
	tagsPath := "tags.json"

	// Check if tags.json exists
	if _, err := os.Stat(tagsPath); os.IsNotExist(err) {
		return fmt.Errorf("tags.json not found")
	}

	data, err := os.ReadFile(tagsPath)
	if err != nil {
		return fmt.Errorf("failed to read tags.json: %w", err)
	}

	g.tags = &TagDatabase{}
	if err := json.Unmarshal(data, g.tags); err != nil {
		return fmt.Errorf("failed to parse tags.json: %w", err)
	}

	log.Printf("Loaded tags database with %d episodes", len(g.tags.Episodes))
	return nil
}

// convertToWebappEpisodes converts collector episodes to webapp episodes
func (g *Generator) convertToWebappEpisodes(episodes []collector.Episode, lazy bool) []Episode {
	var webappEpisodes []Episode

	for _, ep := range episodes {
		webappEp := Episode{
			ID:          g.generateEpisodeID(ep.Title),
			Title:       ep.Title,
			Description: ep.Description,
			Duration:    ep.Duration,
			Date:        ep.Date,
			ParsedDate:  g.parseDate(ep.Date),
			Link:        ep.Link,
			AudioURL:    g.cleanupURL(ep.AudioURL),
			Image:       g.getImageURL(ep, lazy),
			Filename:    ep.Filename,
			JSONFile:    ep.JSONFile,
			Available:   g.checkEpisodeAvailability(ep, lazy),
			Tags:        g.extractTags(ep.Title, ep.Description),
			Category:    g.categorizeEpisode(ep.Title, ep.Description),
		}

		// Get file size if available
		if !lazy && ep.Filename != "" {
			audioPath := filepath.Join(g.dataDir, ep.Filename)
			if info, err := os.Stat(audioPath); err == nil {
				webappEp.FileSize = info.Size()
			}
		}

		webappEpisodes = append(webappEpisodes, webappEp)
	}

	return webappEpisodes
}

// generateStats creates statistics from the episodes
func (g *Generator) generateStats(episodes []Episode) Stats {
	stats := Stats{
		TotalEpisodes:  len(episodes),
		AudioFormats:   []string{"mp3"},
		Categories:     []string{},
		LastUpdated:    time.Now(),
		AvailableCount: 0,
		TotalFileSize:  0,
		TotalSeconds:   0,
	}

	var dates []time.Time
	categoryMap := make(map[string]bool)

	for _, ep := range episodes {
		if ep.Available {
			stats.AvailableCount++
		}

		stats.TotalFileSize += ep.FileSize

		// Parse duration and add to total
		if seconds := g.parseDurationToSeconds(ep.Duration); seconds > 0 {
			stats.TotalSeconds += seconds
		}

		// Collect dates
		if !ep.ParsedDate.IsZero() {
			dates = append(dates, ep.ParsedDate)
		}

		// Collect categories
		if ep.Category != "" {
			categoryMap[ep.Category] = true
		}
	}

	// Calculate total duration string
	stats.TotalDuration = g.formatDuration(stats.TotalSeconds)

	// Set date range
	if len(dates) > 0 {
		sort.Slice(dates, func(i, j int) bool {
			return dates[i].Before(dates[j])
		})
		stats.DateRange = DateRange{
			Earliest: dates[0].Format("2006-01-02"),
			Latest:   dates[len(dates)-1].Format("2006-01-02"),
		}
	}

	// Convert category map to slice
	for category := range categoryMap {
		stats.Categories = append(stats.Categories, category)
	}
	sort.Strings(stats.Categories)

	return stats
}

// createConfig creates the webapp configuration
func (g *Generator) createConfig(lazy bool) Config {
	supportsModes := []string{"streaming"}
	if !lazy {
		supportsModes = append(supportsModes, "local")
	}

	return Config{
		Title:         "En Guàrdia - Història de Catalunya",
		Description:   "Programa d'història de Catalunya Ràdio amb tots els episodis disponibles",
		Language:      "ca",
		AudioBaseURL:  "/audio",
		SupportsModes: supportsModes,
		Version:       "2.0.0",
		BuildTime:     time.Now().Format(time.RFC3339),
		Theme: Theme{
			PrimaryColor:   "#d32f2f",
			SecondaryColor: "#1976d2",
			AccentColor:    "#ff9800",
		},
	}
}

// Helper functions

func (g *Generator) generateEpisodeID(title string) string {
	// Extract episode number if present, otherwise use title hash
	if num := g.extractEpisodeNumber(title); num > 0 {
		return fmt.Sprintf("ep-%d", num)
	}

	// Create ID from title
	id := strings.ToLower(title)
	id = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(id, "-")
	id = strings.Trim(id, "-")
	if len(id) > 50 {
		id = id[:50]
	}
	return id
}

func (g *Generator) extractEpisodeNumber(title string) int {
	// Try to extract episode number from title
	re := regexp.MustCompile(`^(\d+)\s*-`)
	matches := re.FindStringSubmatch(title)
	if len(matches) > 1 {
		if num, err := strconv.Atoi(matches[1]); err == nil {
			return num
		}
	}
	return 0
}

func (g *Generator) parseDate(dateStr string) time.Time {
	// Try different date formats
	formats := []string{
		"02/01/2006 15:04:05",
		"2006-01-02 15:04:05",
		"2006-01-02",
		"02/01/2006",
	}

	for _, format := range formats {
		if t, err := time.Parse(format, dateStr); err == nil {
			return t
		}
	}

	return time.Time{}
}

func (g *Generator) checkEpisodeAvailability(ep collector.Episode, lazy bool) bool {
	if lazy {
		return ep.AudioURL != ""
	}

	// Check if local file exists
	if ep.Filename != "" {
		audioPath := filepath.Join(g.dataDir, ep.Filename)
		if info, err := os.Stat(audioPath); err == nil && info.Size() > 1024*1024 { // At least 1MB
			return true
		}
	}

	return ep.AudioURL != ""
}

func (g *Generator) extractTags(title, description string) []string {
	var tags []string

	// If tags database is loaded, try to find tags for this episode
	if g.tags != nil {
		// Try to find episode by title match
		episodeKey := g.generateTagKey(title)
		if tagData, exists := g.tags.Episodes[episodeKey]; exists {
			// Collect all tags from all categories
			tags = append(tags, tagData.Tags.Topics...)
			tags = append(tags, tagData.Tags.Locations...)
			tags = append(tags, tagData.Tags.Civilizations...)
			tags = append(tags, tagData.Tags.Events...)
			tags = append(tags, tagData.Tags.Periods...)

			// Remove duplicates and return
			return g.removeDuplicateTags(tags)
		}

		// If exact match not found, try fuzzy matching by title similarity
		for key, tagData := range g.tags.Episodes {
			if g.titleSimilarity(title, tagData.Title) > 0.8 {
				tags = append(tags, tagData.Tags.Topics...)
				tags = append(tags, tagData.Tags.Locations...)
				tags = append(tags, tagData.Tags.Civilizations...)
				tags = append(tags, tagData.Tags.Events...)
				tags = append(tags, tagData.Tags.Periods...)

				log.Printf("Found fuzzy match for '%s' -> '%s' (key: %s)", title, tagData.Title, key)
				return g.removeDuplicateTags(tags)
			}
		}
	}

	// Fallback to basic keyword extraction if no tags database or no match found
	keywords := map[string]string{
		"guerra":    "guerra",
		"batalla":   "batalla",
		"setge":     "setge",
		"rei":       "monarquia",
		"comte":     "noblesa",
		"catalunya": "catalunya",
		"barcelona": "barcelona",
		"medieval":  "edat-mitjana",
		"romà":      "roma",
		"musulmà":   "islam",
		"cristià":   "cristianisme",
		"templers":  "ordes-militars",
	}

	text := strings.ToLower(title + " " + description)
	for keyword, tag := range keywords {
		if strings.Contains(text, keyword) {
			tags = append(tags, tag)
		}
	}

	return tags
}

func (g *Generator) categorizeEpisode(title, description string) string {
	text := strings.ToLower(title + " " + description)

	categories := map[string][]string{
		"Guerres i Batalles": {"guerra", "batalla", "setge", "militar"},
		"Edat Mitjana":       {"medieval", "feudal", "cavaller", "castell"},
		"Època Romana":       {"romà", "roma", "imperi"},
		"Monarquia":          {"rei", "reina", "príncep", "corona"},
		"Catalunya Moderna":  {"segadors", "successió", "felip"},
		"Segle XX":           {"república", "guerra civil", "franquisme"},
		"Cultura i Societat": {"cuina", "medicina", "escola", "música"},
		"Personatges":        {"biografia", "vida de"},
	}

	for category, keywords := range categories {
		for _, keyword := range keywords {
			if strings.Contains(text, keyword) {
				return category
			}
		}
	}

	return "General"
}

func (g *Generator) parseDurationToSeconds(duration string) int {
	// Parse duration like "00:53:19" or "53:19" or "Durada: 54 min"
	duration = strings.TrimSpace(duration)

	// Handle "Durada: XX min" format
	if strings.Contains(duration, "min") {
		re := regexp.MustCompile(`(\d+)\s*min`)
		matches := re.FindStringSubmatch(duration)
		if len(matches) > 1 {
			if minutes, err := strconv.Atoi(matches[1]); err == nil {
				return minutes * 60
			}
		}
	}

	// Handle HH:MM:SS or MM:SS format
	parts := strings.Split(duration, ":")
	if len(parts) == 3 {
		// HH:MM:SS
		if h, err := strconv.Atoi(parts[0]); err == nil {
			if m, err := strconv.Atoi(parts[1]); err == nil {
				if s, err := strconv.Atoi(parts[2]); err == nil {
					return h*3600 + m*60 + s
				}
			}
		}
	} else if len(parts) == 2 {
		// MM:SS
		if m, err := strconv.Atoi(parts[0]); err == nil {
			if s, err := strconv.Atoi(parts[1]); err == nil {
				return m*60 + s
			}
		}
	}

	return 0
}

func (g *Generator) formatDuration(seconds int) string {
	hours := seconds / 3600
	minutes := (seconds % 3600) / 60
	secs := seconds % 60

	if hours > 0 {
		return fmt.Sprintf("%d:%02d:%02d", hours, minutes, secs)
	}
	return fmt.Sprintf("%d:%02d", minutes, secs)
}

func (g *Generator) getImageURL(ep collector.Episode, lazy bool) string {
	// If in lazy mode or no image filename, use remote URL
	if lazy || ep.ImageFilename == "" {
		return g.cleanupURL(ep.Image)
	}

	// Check if local image file exists
	if ep.ImageFilename != "" {
		imagePath := filepath.Join(g.dataDir, ep.ImageFilename)
		if info, err := os.Stat(imagePath); err == nil && info.Size() > 0 {
			// For GitHub Pages, use relative path to images directory
			return "./images/" + filepath.Base(ep.ImageFilename)
		}
	}

	// Fallback to remote URL if local file doesn't exist
	return g.cleanupURL(ep.Image)
}

func (g *Generator) cleanupURL(url string) string {
	// Fix duplicated base URLs in image and audio URLs
	// Pattern: https://img.3cat.cat/multimedia/https://img.3cat.cat/multimedia/...
	if strings.Contains(url, "https://img.3cat.cat/multimedia/https://img.3cat.cat/multimedia/") {
		// Remove the first occurrence of the base URL
		return strings.Replace(url, "https://img.3cat.cat/multimedia/https://img.3cat.cat/multimedia/", "https://img.3cat.cat/multimedia/", 1)
	}

	// Also handle http duplications
	if strings.Contains(url, "http://img.3cat.cat/multimedia/http://img.3cat.cat/multimedia/") {
		return strings.Replace(url, "http://img.3cat.cat/multimedia/http://img.3cat.cat/multimedia/", "http://img.3cat.cat/multimedia/", 1)
	}

	return url
}

func (g *Generator) writeJSONFile(filename string, data interface{}) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			log.Printf("Warning: failed to close file %s: %v", filename, closeErr)
		}
	}()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

// generateTagKey creates a key for looking up episodes in the tags database
func (g *Generator) generateTagKey(title string) string {
	// Create a normalized key from the title, similar to how the tagger creates keys
	key := strings.ToLower(title)
	key = regexp.MustCompile(`[^a-z0-9\s]+`).ReplaceAllString(key, "")
	key = regexp.MustCompile(`\s+`).ReplaceAllString(key, "-")
	key = strings.Trim(key, "-")
	return key
}

// removeDuplicateTags removes duplicate tags from a slice
func (g *Generator) removeDuplicateTags(tags []string) []string {
	seen := make(map[string]bool)
	var result []string

	for _, tag := range tags {
		if tag != "" && !seen[tag] {
			seen[tag] = true
			result = append(result, tag)
		}
	}

	return result
}

// titleSimilarity calculates similarity between two titles (simple implementation)
func (g *Generator) titleSimilarity(title1, title2 string) float64 {
	// Normalize titles
	norm1 := strings.ToLower(regexp.MustCompile(`[^a-z0-9\s]+`).ReplaceAllString(title1, ""))
	norm2 := strings.ToLower(regexp.MustCompile(`[^a-z0-9\s]+`).ReplaceAllString(title2, ""))

	// Simple word-based similarity
	words1 := strings.Fields(norm1)
	words2 := strings.Fields(norm2)

	if len(words1) == 0 || len(words2) == 0 {
		return 0.0
	}

	// Count common words
	wordSet1 := make(map[string]bool)
	for _, word := range words1 {
		wordSet1[word] = true
	}

	commonWords := 0
	for _, word := range words2 {
		if wordSet1[word] {
			commonWords++
		}
	}

	// Calculate similarity as ratio of common words to total unique words
	totalWords := len(words1) + len(words2) - commonWords
	if totalWords == 0 {
		return 1.0
	}

	return float64(commonWords*2) / float64(totalWords)
}

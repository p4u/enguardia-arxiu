package generator

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/p4u/enguardia-web/internal/collector"
)

// TagSystem handles episode tagging functionality
type TagSystem struct {
	dataDir string
}

// EpisodeTags represents the tags for a single episode
type EpisodeTags struct {
	Title         string              `json:"title"`
	Tags          map[string][]string `json:"tags"`
	Confidence    float64             `json:"confidence,omitempty"`
	AutoGenerated bool                `json:"auto_generated,omitempty"`
}

// TagsData represents the complete tags.json structure
type TagsData struct {
	Version     string                 `json:"version"`
	LastUpdated string                 `json:"last_updated"`
	Episodes    map[string]EpisodeTags `json:"episodes"`
	Taxonomy    TagTaxonomy            `json:"taxonomy"`
}

// TagTaxonomy defines the available tag categories and their values
type TagTaxonomy struct {
	Periods       []string `json:"periods"`
	Topics        []string `json:"topics"`
	Locations     []string `json:"locations"`
	Civilizations []string `json:"civilizations"`
	Events        []string `json:"events"`
}

// NewTagSystem creates a new tag system
func NewTagSystem(dataDir string) *TagSystem {
	return &TagSystem{
		dataDir: dataDir,
	}
}

// GenerateTagsFile creates the initial tags.json file with discovered tags
func (ts *TagSystem) GenerateTagsFile(outputPath string) error {
	log.Println("Generating tags.json file with automatic tag discovery...")

	// Load episodes
	episodes, err := ts.loadEpisodes()
	if err != nil {
		return fmt.Errorf("failed to load episodes: %w", err)
	}

	// Initialize tag data structure
	tagsData := TagsData{
		Version:     "1.0.0",
		LastUpdated: "2025-08-22T14:00:00Z",
		Episodes:    make(map[string]EpisodeTags),
		Taxonomy:    ts.createTaxonomy(),
	}

	// Process each episode
	for _, episode := range episodes {
		episodeKey := ts.generateEpisodeKey(episode.Title)
		tags := ts.discoverTags(episode.Title, episode.Description)

		tagsData.Episodes[episodeKey] = EpisodeTags{
			Title:         episode.Title,
			Tags:          tags,
			Confidence:    ts.calculateConfidence(tags),
			AutoGenerated: true,
		}
	}

	// Write tags file
	if err := ts.writeTagsFile(outputPath, tagsData); err != nil {
		return fmt.Errorf("failed to write tags file: %w", err)
	}

	log.Printf("Successfully generated tags.json with %d episodes", len(tagsData.Episodes))
	ts.printTagStatistics(tagsData)

	return nil
}

// loadEpisodes loads episodes from JSON files
func (ts *TagSystem) loadEpisodes() ([]collector.Episode, error) {
	var episodes []collector.Episode

	files, err := filepath.Glob(filepath.Join(ts.dataDir, "*.json"))
	if err != nil {
		return nil, fmt.Errorf("failed to glob JSON files: %w", err)
	}

	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			log.Printf("Warning: failed to read file %s: %v", file, err)
			continue
		}

		var episode collector.Episode
		if err := json.Unmarshal(data, &episode); err != nil {
			log.Printf("Warning: failed to parse JSON file %s: %v", file, err)
			continue
		}

		episodes = append(episodes, episode)
	}

	return episodes, nil
}

// generateEpisodeKey creates a consistent key for episode identification
func (ts *TagSystem) generateEpisodeKey(title string) string {
	// Remove episode number prefix and clean title
	key := strings.ToLower(title)

	// Remove episode number pattern (e.g., "123 - " or "123-")
	re := regexp.MustCompile(`^\d+\s*-\s*`)
	key = re.ReplaceAllString(key, "")

	// Replace special characters with hyphens
	key = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(key, "-")
	key = strings.Trim(key, "-")

	// Limit length
	if len(key) > 60 {
		key = key[:60]
	}

	return key
}

// discoverTags analyzes episode title and description to discover relevant tags
func (ts *TagSystem) discoverTags(title, description string) map[string][]string {
	text := strings.ToLower(title + " " + description)
	tags := make(map[string][]string)

	// Discover period tags
	tags["periods"] = ts.discoverPeriods(text)

	// Discover topic tags
	tags["topics"] = ts.discoverTopics(text)

	// Discover location tags
	tags["locations"] = ts.discoverLocations(text)

	// Discover civilization tags
	tags["civilizations"] = ts.discoverCivilizations(text)

	// Discover event tags
	tags["events"] = ts.discoverEvents(text)

	// Remove empty categories
	for category, tagList := range tags {
		if len(tagList) == 0 {
			delete(tags, category)
		}
	}

	return tags
}

// discoverPeriods identifies historical periods from text
func (ts *TagSystem) discoverPeriods(text string) []string {
	var periods []string

	periodPatterns := map[string][]string{
		"prehistoria":        {"prehistòria", "neolític", "paleolític", "bronze", "ferro", "dinosaures"},
		"antiguitat":         {"romà", "roma", "grec", "grècia", "fenici", "ibers", "cartaginesos"},
		"alta-edat-mitjana":  {"carlemany", "carolingi", "visigot", "musulmà", "reconquesta", "comtes"},
		"baixa-edat-mitjana": {"medieval", "feudal", "cavaller", "castell", "templers", "creuades"},
		"edat-moderna":       {"renaixement", "descobriments", "àustries", "felip", "carles v"},
		"segle-xvii":         {"segadors", "guerra dels segadors", "lluís xiv", "tractat pirineus"},
		"segle-xviii":        {"successió", "felip v", "guerra successió", "borbons", "nova planta"},
		"segle-xix":          {"napoleó", "francès", "liberal", "carlista", "industrial", "ferrocarril"},
		"segle-xx":           {"república", "guerra civil", "franquisme", "segona guerra mundial"},
		"contemporani":       {"transició", "democràcia", "autonomia", "generalitat"},
	}

	for period, keywords := range periodPatterns {
		for _, keyword := range keywords {
			if strings.Contains(text, keyword) {
				periods = append(periods, period)
				break
			}
		}
	}

	return ts.removeDuplicates(periods)
}

// discoverTopics identifies main topics from text
func (ts *TagSystem) discoverTopics(text string) []string {
	var topics []string

	topicPatterns := map[string][]string{
		"guerra":       {"guerra", "batalla", "setge", "militar", "combat", "conflicte"},
		"biografia":    {"vida de", "personatge", "figura", "biografia"},
		"politica":     {"rei", "reina", "comte", "duc", "política", "govern", "corts"},
		"religió":      {"església", "bisbe", "monestir", "cristià", "musulmà", "jueu"},
		"cultura":      {"art", "literatura", "música", "teatre", "cultura", "intel·lectual"},
		"economia":     {"comerç", "mercader", "banquer", "moneda", "economia", "industrial"},
		"societat":     {"vida quotidiana", "costums", "família", "dones", "educació"},
		"ciencia":      {"medicina", "tècnica", "invenció", "descobriment", "científic"},
		"arquitectura": {"catedral", "castell", "palau", "construcció", "arquitectura"},
		"esport":       {"futbol", "boxa", "olimpíada", "esport", "competició"},
	}

	for topic, keywords := range topicPatterns {
		for _, keyword := range keywords {
			if strings.Contains(text, keyword) {
				topics = append(topics, topic)
				break
			}
		}
	}

	return ts.removeDuplicates(topics)
}

// discoverLocations identifies geographic locations from text
func (ts *TagSystem) discoverLocations(text string) []string {
	var locations []string

	locationPatterns := map[string][]string{
		"catalunya":   {"catalunya", "català", "barcelon", "girona", "lleida", "tarragona"},
		"espanya":     {"espanya", "espanyol", "castella", "madrid", "toledo"},
		"europa":      {"frança", "itàlia", "alemanya", "anglaterra", "europa"},
		"mediterrani": {"mediterrani", "mallorca", "sardenya", "sicília", "nàpols"},
		"america":     {"amèrica", "cuba", "filipines", "colònies", "nou món"},
		"africa":      {"àfrica", "marroc", "tunísia", "alger"},
		"asia":        {"àsia", "orient", "xina", "índia"},
	}

	for location, keywords := range locationPatterns {
		for _, keyword := range keywords {
			if strings.Contains(text, keyword) {
				locations = append(locations, location)
				break
			}
		}
	}

	return ts.removeDuplicates(locations)
}

// discoverCivilizations identifies civilizations and peoples from text
func (ts *TagSystem) discoverCivilizations(text string) []string {
	var civilizations []string

	civilizationPatterns := map[string][]string{
		"romans":    {"romà", "roma", "imperi romà", "llatí"},
		"grecs":     {"grec", "grècia", "hel·lènic", "atenes", "esparta"},
		"musulmans": {"musulmà", "islam", "àrab", "moro", "andalusí"},
		"cristians": {"cristià", "cristianisme", "catòlic", "església"},
		"catalans":  {"català", "catalunya", "barceloní", "gironí"},
		"francs":    {"franc", "carolingi", "carlemany", "pipí"},
		"visigots":  {"visigot", "gòtic", "toledo", "hispània"},
		"jueus":     {"jueu", "hebreu", "sinagoga", "rabí"},
		"fenicis":   {"fenici", "cartaginès", "cartago", "púnic"},
		"ibers":     {"iber", "ibèric", "indíget", "laietà"},
	}

	for civilization, keywords := range civilizationPatterns {
		for _, keyword := range keywords {
			if strings.Contains(text, keyword) {
				civilizations = append(civilizations, civilization)
				break
			}
		}
	}

	return ts.removeDuplicates(civilizations)
}

// discoverEvents identifies specific historical events from text
func (ts *TagSystem) discoverEvents(text string) []string {
	var events []string

	eventPatterns := map[string][]string{
		"guerra-successio":  {"successió", "almenar", "almansa", "felip v"},
		"guerra-segadors":   {"segadors", "pau claris", "revolució 1640"},
		"guerra-frances":    {"francès", "napoleó", "independència"},
		"guerra-civil":      {"guerra civil", "república", "franco"},
		"reconquesta":       {"reconquesta", "jaume i", "mallorca", "valència"},
		"creuades":          {"creuada", "terra santa", "jerusalem"},
		"descobriments":     {"descobriment", "colom", "amèrica", "nou món"},
		"inquisicio":        {"inquisició", "tribunal", "heretge"},
		"expulsio-jueus":    {"expulsió", "jueus", "1492"},
		"expulsio-moriscos": {"expulsió", "moriscos", "felip iii"},
	}

	for event, keywords := range eventPatterns {
		for _, keyword := range keywords {
			if strings.Contains(text, keyword) {
				events = append(events, event)
				break
			}
		}
	}

	return ts.removeDuplicates(events)
}

// createTaxonomy creates the complete taxonomy of available tags
func (ts *TagSystem) createTaxonomy() TagTaxonomy {
	return TagTaxonomy{
		Periods: []string{
			"prehistoria", "antiguitat", "alta-edat-mitjana", "baixa-edat-mitjana",
			"edat-moderna", "segle-xvii", "segle-xviii", "segle-xix", "segle-xx", "contemporani",
		},
		Topics: []string{
			"guerra", "biografia", "politica", "religió", "cultura", "economia",
			"societat", "ciencia", "arquitectura", "esport",
		},
		Locations: []string{
			"catalunya", "espanya", "europa", "mediterrani", "america", "africa", "asia",
		},
		Civilizations: []string{
			"romans", "grecs", "musulmans", "cristians", "catalans", "francs",
			"visigots", "jueus", "fenicis", "ibers",
		},
		Events: []string{
			"guerra-successio", "guerra-segadors", "guerra-frances", "guerra-civil",
			"reconquesta", "creuades", "descobriments", "inquisicio", "expulsio-jueus", "expulsio-moriscos",
		},
	}
}

// calculateConfidence calculates a confidence score for the discovered tags
func (ts *TagSystem) calculateConfidence(tags map[string][]string) float64 {
	totalTags := 0
	for _, tagList := range tags {
		totalTags += len(tagList)
	}

	// Simple confidence based on number of tags discovered
	if totalTags == 0 {
		return 0.0
	} else if totalTags <= 2 {
		return 0.6
	} else if totalTags <= 4 {
		return 0.8
	} else {
		return 0.9
	}
}

// removeDuplicates removes duplicate strings from a slice
func (ts *TagSystem) removeDuplicates(slice []string) []string {
	keys := make(map[string]bool)
	var result []string

	for _, item := range slice {
		if !keys[item] {
			keys[item] = true
			result = append(result, item)
		}
	}

	return result
}

// writeTagsFile writes the tags data to a JSON file
func (ts *TagSystem) writeTagsFile(outputPath string, data TagsData) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			log.Printf("Warning: failed to close file %s: %v", outputPath, closeErr)
		}
	}()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

// printTagStatistics prints statistics about the generated tags
func (ts *TagSystem) printTagStatistics(data TagsData) {
	tagCounts := make(map[string]map[string]int)

	// Initialize counters
	if len(data.Taxonomy.Periods) > 0 {
		tagCounts["periods"] = make(map[string]int)
	}
	if len(data.Taxonomy.Topics) > 0 {
		tagCounts["topics"] = make(map[string]int)
	}
	if len(data.Taxonomy.Locations) > 0 {
		tagCounts["locations"] = make(map[string]int)
	}
	if len(data.Taxonomy.Civilizations) > 0 {
		tagCounts["civilizations"] = make(map[string]int)
	}
	if len(data.Taxonomy.Events) > 0 {
		tagCounts["events"] = make(map[string]int)
	}

	// Count tag usage
	for _, episode := range data.Episodes {
		for category, tags := range episode.Tags {
			if tagCounts[category] == nil {
				tagCounts[category] = make(map[string]int)
			}
			for _, tag := range tags {
				tagCounts[category][tag]++
			}
		}
	}

	// Print statistics
	log.Println("\n=== TAG STATISTICS ===")
	for category, counts := range tagCounts {
		if len(counts) == 0 {
			continue
		}

		log.Printf("\n%s:", strings.ToUpper(category))

		// Sort by count
		type tagCount struct {
			tag   string
			count int
		}
		var sorted []tagCount
		for tag, count := range counts {
			sorted = append(sorted, tagCount{tag, count})
		}
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].count > sorted[j].count
		})

		// Print top tags
		for i, tc := range sorted {
			if i >= 10 { // Limit to top 10
				break
			}
			log.Printf("  %s: %d episodes", tc.tag, tc.count)
		}
	}
}
